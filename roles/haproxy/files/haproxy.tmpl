global
    maxconn {{or (key "service/haproxy/maxconn") 2048}}
    log /dev/log local0
    debug
    tune.ssl.default-dh-param 2048

defaults
    mode http
    option redispatch
    timeout connect {{or (key "service/haproxy/timeouts/connect") "5s"}}
    timeout client {{or (key "service/haproxy/timeouts/client") "50s"}}
    timeout server {{or (key "service/haproxy/timeouts/server") "50s"}}
    timeout http-request {{or (key "service/haproxy/timeouts/http-request") "5s"}}
    timeout tunnel {{or (key "service/haproxy/timeouts/tunnel") "1h"}}

# frontend used to return health status without requiring SSL
frontend haproxy_status
    bind 0.0.0.0:34180      # 34180 means HEALTH ;)
    # create a status URI in /haproxy_status that will return
    # a 200 is backend is healthy, and 503 if it isn't. This
    # URI is queried by the ELB.
    acl backend_dead nbsrv(consul_backend) lt 1
    monitor-uri /haproxy_status
    monitor fail if backend_dead

listen stats
    bind 127.0.0.1:9000
    stats enable
    stats uri /haproxy?stats
    stats realm Haproxy\ Statistics
    stats auth admin:admin
    option httpclose

frontend www-http
    bind *:80

    # Force HTTPS
    redirect scheme https if !{ ssl_fc }

frontend www-https
    bind *:443 ssl crt {{ env "SSL_CERT" }} ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK no-sslv3

    option forwardfor
    option http-server-close
    reqadd X-Forwarded-Proto:\ https

    # X-Unique-ID header in requests
    unique-id-format %{+X}o\ %ci:%cp_%fi:%fp_%Ts_%rt:%pid
    unique-id-header X-Unique-ID

    # Gzip
    compression algo gzip
    compression type text/html text/plain text/javascript application/javascript application/xml text/css application/json application/x-javascript image/svg+xml

    # Remove trailing slashes
    acl is_www_host hdr(host) -i {{env "ENDOR_SUBDOMAIN" }}.{{env "HAPROXY_DOMAIN"}}
    acl has_trailing_slash path_end /
    acl is_root path /
    http-request set-path %[path,regsub(/$,)] if has_trailing_slash is_www_host !is_root

    # GAE Proxy
    acl is_gae_path path_beg -i -f {{env "GAE_ROUTES_FILE"}}
    acl is_endor_path path -i -f {{env "ENDOR_ROUTES_FILE"}}
    acl is_endor_path path_beg -i -f {{env "ENDOR_PREFIX_ROUTES_FILE"}}
    use_backend gae_backend if is_www_host is_gae_path !is_endor_path

    # Websockets enabled backends
    acl is_websocket hdr(Upgrade) -i WebSocket
    {{range $tag, $services := services | byTag}}{{ if eq $tag "websockets" }}{{range $services}}
    acl host_{{.Name}} hdr(host) -i {{.Name}}.{{env "HAPROXY_DOMAIN"}}
    use_backend {{.Name}}_backend_ws if host_{{.Name}} is_websocket
    {{end}}{{end}}{{end}}

    # Generated automatically by consul-template
    {{range $tag, $services := services | byTag}}{{ if eq $tag "public" }}{{range $services}}
    acl host_{{.Name}} hdr(host) -i {{.Name}}.{{env "HAPROXY_DOMAIN"}}
    use_backend {{.Name}}_backend if host_{{.Name}}
    {{end}}{{end}}{{end}}

    # Inject X-Berlioz-Country header with two-letter country code (see NI-461)
    http-request set-header X-Berlioz-Country %[src,map_ip(/etc/haproxy/geolocation.txt)]

# ProxyPass / ReverseProxyPass to GAE
backend gae_backend
    http-request set-header Host {{env "GAE_SUBDOMAIN"}}.udacity.com
    reqirep ^([^\ :]*)\ {{env "ENDOR_SUBDOMAIN"}}.udacity.com/(.*) \1\ {{env "GAE_SUBDOMAIN"}}.udacity.com/\2

    acl hdr_location res.hdr(Location) -m found
    rspirep ^Location:\ (http|https)://{{env "GAE_SUBDOMAIN"}}.udacity.com(.*) Location:\ \1://{{env "ENDOR_SUBDOMAIN"}}.udacity.com\2

    # TODO (Angel): Proxy pass cookies
    server gae {{env "GAE_SUBDOMAIN"}}.udacity.com:443 ssl verify none

{{range $tag, $services := services | byTag}}{{ if eq $tag "public" }}{{range $services}}
backend {{.Name}}_backend
{{range service .Name}}
   server {{.Node}} {{.Address}}:{{.Port}}{{end}}
{{end}}{{end}}{{end}}

{{range $tag, $services := services | byTag}}{{ if eq $tag "websockets" }}{{range $services}}
backend {{.Name}}_backend_ws
   no option httpclose
{{range service .Name}}
   server {{.Node}} {{.Address}}:{{.Port}}{{end}}
{{end}}{{end}}{{end}}

backend consul_backend
{{range service "consul"}}
   server {{.Node}} {{.Address}}:{{.Port}}{{end}}
